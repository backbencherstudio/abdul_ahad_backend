generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  type                String?
  provider            String?
  provider_account_id String?
  refresh_token       String?
  access_token        String?
  expires_at          DateTime?
  token_type          String?
  scope               String?
  id_token            String?
  session_state       String?

  @@unique([provider, provider_account_id])
  @@map("accounts")
}

model User {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  approved_at  DateTime?
  availability String?

  email      String? @unique
  username   String? @unique
  name       String? @db.VarChar(255)
  first_name String? @db.VarChar(255)
  last_name  String? @db.VarChar(255)
  password   String? @db.VarChar(255)
  domain     String? @unique
  avatar     String?

  phone_number  String?
  country       String?
  state         String?
  city          String?
  address       String?
  zip_code      String?
  gender        String?
  date_of_birth DateTime? @db.Date

  // billing id. e.g. stripe customer id
  billing_id String?

  email_verified_at DateTime?

  is_two_factor_enabled Int?    @default(0)
  two_factor_secret     String? // secret key for two factor authentication

  accounts                  Account[]
  creator_conversations     Conversation[] @relation("creator")
  participant_conversations Conversation[] @relation("participant")
  receiver_messages         Message[]      @relation("receiver")
  sender_messages           Message[]      @relation("sender")
  receiver_notifications    Notification[] @relation("receiver")
  sender_notifications      Notification[] @relation("sender")

  user_payment_methods        UserPaymentMethod[]
  user_settings               UserSetting[]
  ucodes                      Ucode[]
  roles                       Role[]
  role_users                  RoleUser[]
  payment_transactions        PaymentTransaction[] @relation("UserPaymentTransactions")
  garage_payment_transactions PaymentTransaction[] @relation("GaragePaymentTransactions")
  garage_orders               Order[]              @relation("GarageOrders")

  garage_name     String? // Name of Garage
  vts_number      String? // VTS Number (Vehicle Testing Station)
  primary_contact String? // Primary Contact Person

  type     UserRole  @default(DRIVER)
  vehicles Vehicle[]
  orders   Order[]   @relation("DriverOrders")
  services Service[] @relation("GarageServices")
  Order    Order[]
  Service  Service[]

  invoices_issued   Invoice[] @relation("GarageInvoices")
  invoices_received Invoice[] @relation("DriverInvoices")

  // Vehicle-related data for retention (only for DRIVER type)
  vehicle_registration_number String? // Last/current vehicle number
  vehicle_make                String? // Last/current vehicle make
  vehicle_model               String? // Last/current vehicle model
  last_mot_date               DateTime? // Last MOT test date
  last_mot_expiry_date        DateTime? // Last MOT expiry date
  last_booking_date           DateTime? // Last booking date
  TimeSlot                    TimeSlot[]

  // For TimeSlot relation (as garage)
  garageTimeSlots TimeSlot[] @relation("GarageTimeSlots")
  schedule        Schedule?
  garage_subscriptions GarageSubscription[]

  // Add this field for reset state tracking
  is_reset Boolean @default(false)

  @@index([type])
  @@map("users")
}

model Ucode {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())
  status     Int?     @default(1) @db.SmallInt

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  token      String?
  email      String?
  expired_at DateTime?

  @@map("ucodes")
}

model Role {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  title  String?
  name   String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  permission_roles PermissionRole[]
  role_users       RoleUser[]
  permissions      Permission[]     @relation("PermissionToRole")

  @@map("roles")
}

model Permission {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  title      String?
  action     String?
  subject    String?
  conditions String?
  fields     String?

  permission_roles PermissionRole[]
  roles            Role[]           @relation("PermissionToRole")

  @@map("permissions")
}

model PermissionRole {
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  permission_id String
  permission    Permission @relation(fields: [permission_id], references: [id], onDelete: Cascade)

  role_id String
  role    Role   @relation(fields: [role_id], references: [id], onDelete: Cascade)

  @@id([permission_id, role_id])
  @@map("permission_roles")
}

model RoleUser {
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  role_id String
  role    Role   @relation(fields: [role_id], references: [id], onDelete: Cascade)

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([role_id, user_id])
  @@map("role_users")
}

// this table stores notification event
model NotificationEvent {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  type   String?
  text   String?

  notifications Notification[]

  @@map("notification_events")
}

model Notification {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  read_at DateTime?

  status Int? @default(1) @db.SmallInt

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  notification_event_id String?
  notification_event    NotificationEvent? @relation(fields: [notification_event_id], references: [id])

  entity_id String?

  @@map("notifications")
}

model UserPaymentMethod {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  payment_method_id String?
  checkout_id       String?

  @@map("user_payment_methods")
}

model PaymentTransaction {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  store_id String?

  user_id String?
  user    User?   @relation("UserPaymentTransactions", fields: [user_id], references: [id])

  order_id String?

  withdraw_via     String?  @default("wallet")
  provider         String?
  reference_number String?
  // status           String?  @default("pending")
  raw_status       String?
  amount           Decimal?
  currency         String?
  paid_amount      Decimal?
  paid_currency    String?

  order     Order?        @relation(fields: [order_id], references: [id])
  garage_id String?
  garage    User?         @relation("GaragePaymentTransactions", fields: [garage_id], references: [id])
  type      PaymentType
  status    PaymentStatus

  @@map("payment_transactions")
}

// ---------Start Chat schema---------

enum MessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
}

// message is used for conversation
model Message {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status MessageStatus? @default(PENDING)

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  conversation_id String?
  conversation    Conversation? @relation(fields: [conversation_id], references: [id], onDelete: Cascade)

  attachment_id String?
  attachment    Attachment? @relation(fields: [attachment_id], references: [id])

  message String?

  @@map("messages")
}

// this table stores attachment of message
model Attachment {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name     String?
  type     String?
  size     Int?
  file     String?
  file_alt String?

  messages Message[]

  @@map("attachments")
}

// this table stores conversation
model Conversation {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  creator_id String?
  creator    User?   @relation("creator", fields: [creator_id], references: [id])

  participant_id String?
  participant    User?   @relation("participant", fields: [participant_id], references: [id])

  messages Message[]

  @@map("conversations")
}

// ---------End Chat schema---------

model Faq {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  sort_order Int?    @default(0)
  question   String?
  answer     String?

  @@map("faqs")
}

model Contact {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  first_name   String?
  last_name    String?
  email        String?
  phone_number String?
  message      String?

  @@map("contacts")
}

model SocialMedia {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  sort_order Int?    @default(0)
  name       String?
  url        String?
  icon       String?

  @@map("social_medias")
}

model WebsiteInfo {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name                String?
  phone_number        String?
  email               String?
  address             String?
  logo                String?
  favicon             String?
  copyright           String?
  cancellation_policy String?

  @@map("website_infos")
}

model Setting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  category      String?
  label         String?
  description   String?
  key           String? @unique
  default_value String?

  user_settings UserSetting[]

  @@map("settings")
}

model UserSetting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  setting_id String?
  setting    Setting? @relation(fields: [setting_id], references: [id])

  value String?

  @@map("user_settings")
}

// this table stores example
// model Note {
//   id                String  @id @default(cuid())
//   created_at DateTime  @default(now())
//   updated_at DateTime  @default(now())
//   deleted_at DateTime?
//   status     Int?      @default(1) @db.SmallInt

//   title String?
//   body  String? @db.Text

//   tenant_id Int?
//   tenant    Organization? @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
//   @@map("posts")
// }

// --- ENUMS ---

enum UserRole {
  ADMIN
  DRIVER
  GARAGE
}

enum OrderStatus {
  PENDING
  ACCEPTED
  REJECTED
  COMPLETED
  CANCELLED
}

enum ServiceType {
  MOT
  RETEST
  ADDITIONAL
}

enum PaymentType {
  SUBSCRIPTION
  ORDER
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum RestrictionType {
  HOLIDAY
  BREAK
}

// --- NEW MODELS ---

model Vehicle {
  id                  String      @id @default(cuid())
  created_at          DateTime    @default(now())
  updated_at          DateTime    @default(now())
  user_id             String
  user                User        @relation(fields: [user_id], references: [id])
  registration_number String      @unique
  make                String?
  model               String?
  color               String?
  fuel_type           String?
  year_of_manufacture Int?
  engine_capacity     Int?
  co2_emissions       Int?
  mot_expiry_date     DateTime?
  dvla_data           String?
  mot_data            String?
  mot_reports         MotReport[]
  orders              Order[]
}

model Order {
  id                   String               @id @default(cuid())
  created_at           DateTime             @default(now())
  updated_at           DateTime             @default(now())
  driver_id            String
  driver               User                 @relation("DriverOrders", fields: [driver_id], references: [id])
  vehicle_id           String
  vehicle              Vehicle              @relation(fields: [vehicle_id], references: [id])
  garage_id            String
  garage               User                 @relation("GarageOrders", fields: [garage_id], references: [id])
  order_date           DateTime
  status               OrderStatus          @default(PENDING)
  total_amount         Decimal?
  items                OrderItem[]
  payment_transactions PaymentTransaction[]
  User                 User?                @relation(fields: [userId], references: [id])
  userId               String?
  invoices             Invoice[]

  // FIXED: Add @unique to timeSlotId for one-to-one relation
  slot_id    String?   @unique
  slot       TimeSlot? @relation("OrderSlot", fields: [timeSlotId], references: [id])
  timeSlotId String?   @unique // FIXED: Add @unique here
}

model Service {
  id         String      @id @default(cuid())
  created_at DateTime    @default(now())
  updated_at DateTime    @default(now())
  garage_id  String
  garage     User        @relation("GarageServices", fields: [garage_id], references: [id])
  name       String
  type       ServiceType
  price      Decimal?
  items      OrderItem[]
  User       User?       @relation(fields: [userId], references: [id])
  userId     String?
}

model OrderItem {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())
  order_id   String
  order      Order    @relation(fields: [order_id], references: [id])
  service_id String
  service    Service  @relation(fields: [service_id], references: [id])
  quantity   Int      @default(1)
  price      Decimal
}

model MotReport {
  id                   String      @id @default(cuid())
  created_at           DateTime    @default(now())
  updated_at           DateTime    @default(now())
  vehicle_id           String
  vehicle              Vehicle     @relation(fields: [vehicle_id], references: [id])
  test_number          String?
  test_date            DateTime?
  expiry_date          DateTime?
  status               String? // PASSED, FAILED
  odometer_value       Int?
  odometer_unit        String?
  odometer_result_type String?
  data_source          String?
  registration_at_test String?
  defects              MotDefect[] // Relation to defects

  @@index([vehicle_id])
  @@index([status])
  @@index([test_date])
}

model MotDefect {
  id            String    @id @default(cuid())
  created_at    DateTime  @default(now())
  updated_at    DateTime  @default(now())
  mot_report_id String
  mot_report    MotReport @relation(fields: [mot_report_id], references: [id])
  type          String // e.g. ADVISORY, MAJOR, FAIL, USER ENTERED
  text          String
  dangerous     Boolean

  @@index([mot_report_id])
  @@index([dangerous])
}

model Invoice {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  invoice_number String @unique // e.g., INV-001
  garage_id      String
  garage         User   @relation("GarageInvoices", fields: [garage_id], references: [id])

  driver_id String
  driver    User   @relation("DriverInvoices", fields: [driver_id], references: [id])

  order_id String?
  order    Order?  @relation(fields: [order_id], references: [id])

  membership_period String? // e.g., "May 1 - May 31, 2025"
  issue_date        DateTime      @default(now())
  due_date          DateTime?
  amount            Decimal
  status            InvoiceStatus @default(PENDING)

  pdf_url String? // Generated PDF file URL

  @@map("invoices")
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}
enum ModificationType {
  MANUAL_BLOCK  // When garage manually blocks a slot
  BOOKED       // When a customer books a slot
  TIME_MODIFIED
}

model Schedule {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  garage_id  String   @unique
  garage     User     @relation(fields: [garage_id], references: [id], onDelete: Cascade)

  start_time    String // "HH:mm" format
  end_time      String // "HH:mm" format
  slot_duration Int     @default(60) // minutes
  restrictions  Json    @default("[]") // Array of restriction objects
  daily_hours   Json?   // Optional per-day hours config: { "0": { is_closed?: boolean, intervals?: [{ start_time, end_time }], slot_duration?: number }, ... }
  is_active     Boolean @default(true)

  // Relations
  time_slots TimeSlot[]

  @@index([garage_id])
  @@map("schedules")
}

model TimeSlot {
  id        String @id @default(cuid())
  garage_id String
  garage    User   @relation("GarageTimeSlots", fields: [garage_id], references: [id])

  // NEW: Use DateTime instead of separate date/time fields
  start_datetime DateTime
  end_datetime   DateTime


  is_available Boolean @default(true)
  is_blocked   Boolean @default(false)

  // FIXED: Add @unique for one-to-one relation and fix relation name
  order_id String? @unique // if booked

  // Relations
  order      Order?    @relation("OrderSlot") // FIXED: Use named relation
  User       User?     @relation(fields: [userId], references: [id])
  userId     String?
  schedule   Schedule? @relation(fields: [scheduleId], references: [id])
  scheduleId String?

  modified_by         String?          // Who modified
  modification_reason String?          // Why modified
  modification_type   ModificationType? // How modified

  @@unique([garage_id, start_datetime])
  @@index([garage_id, start_datetime, end_datetime])
}


enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  CANCELLED
  PAST_DUE
}

model SubscriptionPlan {
  id                        String   @id @default(cuid())
  created_at                DateTime @default(now())
  updated_at                DateTime @updatedAt
  name                      String   @unique
  description               String?
  price_pence               Int
  currency                  String   @default("GBP")
  max_bookings_per_month    Int
  max_vehicles              Int
  priority_support          Boolean  @default(false)
  advanced_analytics        Boolean  @default(false)
  custom_branding           Boolean  @default(false)
  is_active                 Boolean  @default(true)
  stripe_price_id           String?
  stripe_product_id         String?

  garage_subscriptions      GarageSubscription[]

  @@map("subscription_plans")
}

model GarageSubscription {
  id                     String             @id @default(cuid())
  created_at             DateTime           @default(now())
  updated_at             DateTime           @updatedAt

  garage_id              String
  garage                 User               @relation(fields: [garage_id], references: [id], onDelete: Cascade)

  plan_id                String
  plan                   SubscriptionPlan   @relation(fields: [plan_id], references: [id], onDelete: Restrict)

  status                 SubscriptionStatus @default(ACTIVE)

  current_period_start   DateTime?
  current_period_end     DateTime?
  next_billing_date      DateTime?

  price_pence            Int
  currency               String             @default("GBP")

  stripe_subscription_id String?
  stripe_customer_id     String?

  @@index([garage_id])
  @@index([plan_id])
  @@index([status])
  @@map("garage_subscriptions")
}